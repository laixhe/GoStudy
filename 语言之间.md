[TOC]

### 变量之间可能的不同
> golang 没有初始化的基本类型默认为零值 (数值为 0 | 字符串为 "" | 布尔为 false])，**根据值自行判定变量类型**
>
> c# 不能使用初始化的变量 **根据值自行判定变量类型**
>
> typescript 一切对象(未初化)的默认值都是 undefined (最好给于 初始值)，且没有整数类型，只有数字类型，**根据值自行判定变量类型**
>
> dart 一切对象(未初化)的默认值都是 null (最好给于 初始值)，**根据值自行判定变量类型**
>
> python 要注意本身没有类型声明，会根据变量的值，自动把变量转换为正确的数据类型 (在执行间期可以改变为其它类型) ，尽量使用 python3.7 以上版本
>
> php 本身没有类型声明，会根据变量的值，自动把变量转换为正确的数据类型 (在执行间期可以改变为其它类型) ，尽量使用 php7.4 或 php8.x 以上版本 (使用强类型声明)
>
> rust 不能使用初始化的变量，默认创建的变量是不可变的，可变要用 mut 关键字表示 ，**根据值自行判定变量类型**

##### Golang
```
package main
import "fmt"
func main() {
    var world = "World"
	fmt.Println("Hello,", world)
	fmt.Printf("Hello, %s", world)
	// 结果： Hello, World
	
	var a int
	var b string = "中文"
	var c = true // 推断为 bool 类型
	var d = 1.1  // 推断为 float64 类型
	var e = 2    // 推断为 int 类型
	// 结果：[ 0,"中文",true,1.1,2 ]
	fmt.Printf("[ %v,%q,%v,%v,%v ]\n", a, b, c, d, e)

	var arr []int
	// 结果：[] true
	fmt.Println(arr, arr == nil)

	// 以下几种类型为 nil
	// var a *int               // 指针 pointer
	// var a []int              // 切片 slice
	// var a map[string] int    // 字典 map
	// var a chan int           // 通道 channel
	// var a func(string) int   // 函数 function
	// var a interface          // 接口 Interface
}
```

##### C#
```
using System;
namespace ConsoleApp {
    class Program {
        static void Main(string[] args) {
            string world = "World";
            Console.WriteLine("Hello,"+ world);
            Console.WriteLine("Hello,{0}", world);
            // 结果： Hello, World

            //int a; // 最好初始化并赋值
            long a = 100;
            var b = "中文";
            var c = true; // 推断为 bool 类型
            var d = 1.1;  // 推断为 double 类型
            var e = 2;    // 推断为 int 类型
            // 结果： 100, 中文, True, 1.1, 2
            Console.WriteLine("{0}, {1}, {2}, {3}, {4}", a, b, c, d, e);
        }
    }
}
```

##### TypeScript
```
let world = 'World';
console.log(`Hello, ${world}`);

let a: number; // 未初始化的变量值为： undefined
let b: string = '中文'; 
let c = true; // 推断为 boolean 类型
let d = 1.1;  // 推断为 number 类型
// 结果： undefined 中文 true 1.1
console.log(a, b, c, d);

let arr: number[];
// 结果： undefined
console.log(arr);
```

##### Dart
```
void main() {
  var world = 'World';
  print('Hello, $world');
  
  int a;         // 未初始化的变量值为： null
  String b = '中文';
  var c = true; // 推断为 bool 类型
  var d = 1.1;  // 推断为 double 类型
  var e = 2;    // 推断为 int 类型
  // 结果： [null, 中文, true, 1.1, 2]
  print([a,b,c,d,e]);

  List<int> arr;
  // 结果： null
  print(arr);
}
```

##### Python
```
if __name__ == '__main__':
    world = 'World'
    print(f'Hello, {world}')
    print('Hello, %s' % world)
    # 结果： Hello, World
    
    a: int = 1
    b: str = '中文'
    c: bool = False
    d: float = 1.1
    # 结果： <class 'int'> 1 <class 'str'> 中文 <class 'bool'> False <class 'float'> 1.1
    print(type(a), a, type(b), b, type(c), c, type(d), d)

    # 虽然上面标明了数据的类型，但还是可以在执行期间变改数据的类型
    a = '中文'
    b = 1
    c = 1.1
    d = True
    # 结果： <class 'str'> 中文 <class 'int'> 1 <class 'float'> 1.1 <class 'bool'> True
    print(type(a), a, type(b), b, type(c), c, type(d), d)

```

##### PHP
```
<?php
$world = 'World';
echo 'Hello, '.$world;
echo "\n";
echo "Hello, $world";

$a = 123;   // 系统推断为 int 类型
$b = '中文'; // 系统推断为 string 类型
$c = true;  // 系统推断为 bool 类型
$d = 1.1;   // 系统推断为 float 类型
// 上面虽然系统推断出类型，当期间可以随意更改为其它类型
// 结果为：
//array(4) {
//  [0]=>
//  int(123)
//  [1]=>
//  string(6) "中文"
//  [2]=>
//  bool(true)
//  [3]=>
//  float(1.1)
//}
var_dump([$a ,$b, $c, $d]);

// 动态改变类类型
$e = '中文';
var_dump($e); // 结果为： string(6) "中文"
$e = 100;
var_dump($e); // 结果为： int(100)

// 强类型 class (可使用 强类型 来作为数据的承载，防止数据类型被修改)，并给相应的默认值防止没有初始化
class User {
    public int    $uid = 0;
    public string $name = '';
    public bool   $isAuto = false;
    public function __construct(int $uid, string $name, $isAuto){
        $this->uid    = $uid;
        $this->name   = $name;
        $this->isAuto = $isAuto;
    }
}
// 结果为：
// object(User)#1 (3) {
//  ["uid"]=>
//  int(123)
//  ["name"]=>
//  string(6) "中文"
//  ["isAuto"]=>
//  bool(false)
//}
$user = new User(uid: 123, name: "中文", isAuto: false);
var_dump($user);
```

##### Rust
```
fn main() {
    let world = "World";
    println!("Hello, {}", world);
    
    let a: i32 = 0;
    let b: String = String::from("中文");
    let c = true;  // 推断为 bool 类型
    let d = 1.1;   // 推断为 f64 类型
    let e = 2;     // 推断为 i32 类型
    // 结果为：0,中文,true,1.1,2
    println!("{},{},{},{},{}", a, b, c, d, e)
}
```

### 常用数据结构对应和概念转变
> golang：slice(切片)、map(字典)
>
> typescript：Array(数组)、Map(字典)、Set(集合)、tuple(元组)
>
> dart：List(列表)、Map(字典)、Set(集合)
>
> python：list(列表)、dict(字典)、set(集合)、tup(元组)
>
> php：Array(数组) (可以分为：数值数组[类似列表] 和 关联数组[类似字典])
> 
> rust：tuple(元组)、Vec(向量[列表])、Map(hash 哈希)

##### 1. Golang
```
package main
import "fmt"
func main() {
	// slice(切片)的索引从 0 开始
	lists := []string{"a", "b", "c"}
	fmt.Println(lists)         // 结果： [a b c]
	lists = append(lists, "e") // 追加元素
	fmt.Println(lists)         // 结果： [a b c e]

	// map(字典)以 键值对 key:value
	maps := map[string]int{"a": 1, "b": 2, "c": 3}
	fmt.Println(maps) // 结果：map[a:1 b:2 c:3]
	maps["e"] = 4     // 不存在元素就新增元素，存在则修改
	fmt.Println(maps) // 结果：map[a:1 b:2 c:3 e:4]
	delete(maps, "b") // 删除元素，即使删除一个没有的元素也不会报错
	fmt.Println(maps) // 结果：map[a:1 c:3 e:4]
}
```

##### 2. TypeScript
```
// Array(数组)的索引从 0 开始
let array: string[] = ["a", "b"];
array.push('c'); // 追加元素
console.log(array); // 结果： [ 'a', 'b', 'c' ]
array.shift(); // 删除并返回数组的第一个元素
array.pop();   // 删除并返回数组最后一个元素
console.log(array); // 结果： [ 'b' ]

// Map(字典) 是 ES6 中引入的一种新的数据结构
let map: Map<string, number> = new Map([['a', 1], ['b', 2]]);
map.set('c', 3);  // 不存在元素就新增元素，存在则修改
console.log(map); // 结果： { 'a' => 1, 'b' => 2, 'c' => 3 }
map.delete('b');  // 删除 Map 中的元素，删除成功返回 true，失败返回 false

// Set(集合)是一个不重复元素序列
let setT: Set<string> = new Set(['a', 'b', 'a']);
setT.add('c'); // 添加元素
console.log(setT); // 结果： { 'a', 'b', 'c' }

// tuple(元组)，存储的元素数据类型不同（可进行增删改），索引从 0 开始
let tuple: [number, string] = [1, "a"];
console.log(tuple);
```

##### 3. Dart
```
void main() {
  // List(列表)
  // 可以不同的类型 var list = ['a', false, 'abc'];
  var list = <String>['a', 'b'];
  list.add('c');    // 追加元素
  list.remove('a'); // 移除元素，删除成功返回 true，失败返回 false
  print(list);      // 结果： [ b, c]

  // Map(字典)
  var map = <String, int>{'a':1, 'b': 2};
  map['c'] = 3;    // 不存在元素就新增元素，存在则修改
  map.remove('b'); // 移除元素，删除成功返回 其值，失败返回 null
  print(map);      // 结果： {a: 1, c: 3}

  // Set(集合)是一个元素唯一的无序队列
  var setT = <int>{3, 2, 3};
  setT.add(4);
  print(setT); // 结果： {3, 2, 4}
}
```

##### 4. Python
```
if __name__ == '__main__':
    # 数据项不需要具有相同的类型(在项目中最好使用相同类型)

    # list(列表)
    # 索引从 0 开始
    lists = ['a', 'b', 'c']
    print(lists)  # 结果： ['a', 'b', 'c']
    lists.append('d')  # 追加元素
    print(lists)  # 结果： ['a', 'b', 'c', 'd']
    del lists[1]  # 删除元素
    print(lists)  # 结果： ['a', 'c', 'd']

    # dict(字典)以 键值对 key:value
    dicts = {'a': 1, 'b': 2, 'c': 3}
    print(dicts)  # 结果： {'a': 1, 'b': 2, 'c': 3}
    dicts['d'] = 4  # 不存在元素就新增元素，存在则修改
    print(dicts)  # 结果： {'a': 1, 'b': 2, 'c': 3, 'd': 4}
    del dicts['b']  # 删除元素，注意删除一个没有的元素会报错
    print(dicts)  # 结果： {'a': 1, 'c': 3, 'd': 4}

    # set(集合)是一个无序的不重复元素序列
    sets = {'a', 'b', 'a', 'c'}
    print(sets)  # 结果： {'b', 'c', 'a'} 注意显示每次结果顺序都不同
    sets.add('d')  # 追加元素
    print(sets)  # 结果： {'d', 'c', 'a', 'b'}
    sets.remove('b')  # 移除元素，如果元素不存在，则会发生错误
    sets.discard('b')  # 移除元素，如果元素不存在，不会发生错误
    print(sets)  # 结果： {'c', 'd', 'a'}

    # tup(元组)的元素不能新增和修改
    # 索引从 0 开始
    tups = ('1', 2)
    print(tups, tups[1])  # 结果：('1', 2) 2

```

##### 5. PHP
```
<?php
// 不需要具有相同的类型(在项目中最好使用相同类型)

// 数值数组[类似列表]
$list = array('a', 'b', 'c');
var_dump($list);
$list[] = 'd'; // 追加元素
var_dump($list);

// 关联数组[类似字典]
$map = array('a'=>1, 'b'=>2, 'c'=>3);
var_dump($map);
$map['d'] = 4; // 不存在元素就新增元素，存在则修改
var_dump($map);
```

##### 6. Rust

> 元组是不可变的

```
use std::collections::HashMap;
fn main() {
    // 定义数组并初始化
    let array: [i32; 5] = [1,2,3,4,5];
    for arr in &array {
        println!("array={}", arr); // 结果： 1 2 3 4 5
    }
    // 定义数组并初始化数据都为 0
    let array_data: [i32; 5] = [0; 5];
    for arr in &array_data {
        println!("array_data={}", arr); // 结果： 0 0 0 0 0
    }
    
    // 定义元组
    let tuple:(i32,f64,u8) = (-325,4.9,22);
    // 结果： (-325, 4.9, 22) -325 22
    println!("{:?} {} {}", tuple, tuple.0, tuple.2);
    // 元组解构赋值
    let (age,is) = (30,true);
    println!("{} {}",age ,is) // 结果： 30 true
    
    // Vec(向量)(Vector)类似于列表(List)
    //let mut vector: Vec<i32> = Vec::new(); // 与下面效果一样
    let mut vector = vec![1, 2, 3];
    vector.push(4); // 追加元素
    println!("{:?}", vector); // 结果： [1, 2, 3, 4]
    for i in &vector {
        println!("i={}", i)
    }

    // 哈希 map (hash map)
    let mut scores:HashMap<String, i32> = HashMap::new();
    scores.insert(String::from("blue"), 50);
    scores.insert(String::from("yellow"), 20);
    for (key, value) in &scores {
        println!("key={} value={}", key, value);
    }
}
```

### 函数的变化
> golang：由关键字```func```声明，有可变长参数(不定长参数)、没有可选参数、没有默认参数值，可以返回多个不同类型的值
>
> typescript：由关键字```function```声明，有可变长参数、有可选参数、有默认参数值
>
> dart：无关键字，有可选命名参数和默认值
>
> python：由关键字```def```声明，有默认参数值、有可变长参数(不定长参数)
>
> php：由关键字```function```声明，有默认参数值、有可变长参数(不定长参数)
> 
> rust：由关键字```fn```声明，没有可选参数、没有默认参数值，利用**元组**可以返回多个不同类型的值

##### 1. Golang

> 函数可作为参数传递，实现回调
>
> 函数可作为返回值返回

```
package main
import "fmt"

// 无参数，无返回值
func Void() {
	fmt.Println("void")
}
// 可变长参数(不定长参数)
func Names(s ...string) {
	fmt.Println(s)
}
// 有参数，多个返回值
func Test(a int, s string) (int, string) {
	return a, s
}

func main() {
	Void()
	Names("a", "b", "c") // 结果： [a b c]
	max, name := Test(1, "d")
	fmt.Printf("%d, %q\n", max, name) // 结果： 1, "d"
	
	// 函数变量
	var sum = func(a int, b int) int {
		return a + b
	}
	fmt.Println(sum(1, 3)) // 结果： 4
	
}
```

##### 2. TypeScript
```
// 无参数，无返回值
function Void(): void {
    console.log('void');
}
// 可变长参数(不定长参数)
function Names(...s: string[]){
    console.log(s);
}
// 有参数有默认参数值，有返回值
function Test(a: number, b: boolean=false, s?: string): number {
    console.log(a, b, s);
    return a;
}
// 使用元组形式返回多值不同类型的值
function Tuple(): [number, string] {
    return [10, 'Z'];
}

Void();                     // 结果： void
Names('a', 'b', 'c');       // 结果： [ 'a', 'b', 'c' ]
let t = Test(1);            // 结果： 1 false undefined
console.log(t);             // 结果： 1 
let [uid, uname] = Tuple(); // 解构元组
console.log(uid, uname);    // 结果： 10 Z
```

##### 3. Dart
```
// 无参数，无返回值
void Void(){
  print('void');
}
// 有可选命名参数和默认值，有返回值
int Test(int a, {bool b=false, String s}){
  print([a, b, s]);
  return a;
}

void main() {
  Void();          // 结果： void
  var t = Test(1); // 结果： [1, false, null]
  print(t);        // 结果： 1
}
```

##### 4. Python

> 函数的参数传递是通过对象引用来完成的，在内部修改是否影响外部数据要看参数是否是可变类型(list dict)

```
# 无参数，无返回值
def Void():
    print('void')


# 可变长参数(不定长参数)，参数会以元组(tuple)的形式导入
def Names(*s: str):
    print(s, len(s))


# 有参数和默认值，有返回值
def Test(a: int, b: bool = False, s: str = 'str...') -> int:
    print(a, b, s)
    return a


# 关键字可变参数(不定长参数)，参数会以字典(dict)的形式导入
def keyFunc(**kwargs: dict):
    print(kwargs)


if __name__ == '__main__':
    Void()                # 结果： void
    Names('a', 'b', 'c')  # 结果： ('a', 'b', 'c') 3
    t: int = Test(1)      # 结果： 1 False str...
    print(t)              # 结果： 1
    
    dicts = {'name': 'laixhe', 'age': 18}
    keyFunc(**dicts)  # 结果： {'name': 'laixhe', 'age': 18}
    keyFunc(name='laixhe-1', age=19)  # 结果： {'name': 'laixhe-1', 'age': 19}
```

##### 5. PHP
```
<?php
// 无参数，无返回值
function Void(): void {
    echo "void\n";
}

// 可变长参数(不定长参数)
function Names(string ...$s){
    var_dump($s);
}

// 有参数有默认参数值，有返回值
function Test(int $a, bool $b=false, string $s='str...'): int{
    echo $a, ',',$b, ',', $s, "\n";
    return $a;
}

Void();               // 结果： void
Names('a', 'b', 'c'); // 结果：array(3) {[0]=>string(1) "a" [1]=>string(1) "b" [2]=>string(1) "c"}
$t = Test(1);        // 结果： 1,,str...
echo "$t\n";         // 结果： 1
```

##### 6. Rust

> Rust 函数不支持多个返回值，但是我们可以利用元组返回多个值
>
> 没有 `return` 语句则使用最后一条语句的结果作为返回值

```
// 无参数，无返回值
fn void(){
    println!("void")
}
// 有参数，多个返回值
fn test(a:i32, b:bool, s: String) -> (i32, bool) {
    println!("{},{},{}", a, b, s);
    return (a, b);
}

fn main() {
    void();                    // 结果： void
    let (t, tis) = test(1, true, String::from("函数")); // 结果： 1,true,函数
    println!("{},{}", t, tis); // 结果： 1,true
    
    // 匿名函数 lambda
    let sum = |a: i32, b: i32| -> i32 {
        a+b
    };
    println!("{}", sum(1,3)); // 结果： 4
    
    // 使用元组形式返回多值不同类型的值
    let (p1, p2) = pow(2);
    println!("{},{}", p1, p2); // 结果： 4 , 8
    let po = pow(3);
    println!("{},{}", po.0, po.1); // 结果： 9,27
}
// 返回元组
fn pow(n: i32) -> (i32, i32) {
    (n * n, n * n * n)
}
```
### 无形中的面向对象(OOP)
> 面向对象的三个基本特征：封装(Encapsulation)、继承(Inheritance)、多态(Polymorphism)
> 
> golang：并不是一个纯面向对象编程语言，提供了结构体（struct）类型，没有提供类（class）这个关键字，也没有 public、protected、private 语法关键字，没有构造函数、没有析构函数
>
> typescript：由关键字```class```声明，有两个访问修饰符 public 和 private 默认情况下，成员是 public 的
>
> dart：由关键字```class```声明，没有 public、protected、private 语法关键字，_ 下划线直接代表 private 默认情况下，成员是公共的，且没有方法重载，也没有 interface 接口修饰，只有抽象类 abstract
>
> python：由关键字```class```声明，没有 public、protected、private 语法关键字，__ 两个下划线开头代表 private 默认情况下，成员是公共的，没有 interface 接口修饰，也没有抽象类 abstract
>
> php：由关键字```class```声明，
> 
> rust：并不是一个纯面向对象编程语言，没有提供类（class）这个关键字，提供了结构体（struct）类型，而 struct 的成员默认都是 private 的，除非加上 pub关 键词做修饰，没有构造函数、没有析构函数

##### 1. Golang
> 所有的 struct 的方法都是静态绑定，且没有方法重载、没有构造函数、没有析构函数
> 
> 封装特性：首字母大写的就是公有的(public)，首字母小写的话就是私有的(private)，也就是说开头字母是大写的则在其它包中可以被访问，否则只能在本包中访问
> 
> 继承特性：采用的是 匿名组合(composition)(嵌套) 的方式
> 
> 多态特性：依靠 interface(接口) 隐式实现的方式

```
package main
import "fmt"

// 定义接口
// 某个 自定义类型 要 隐式 实现该接口全部方法后就实现这个接口
type BaseInterface interface {
	Show()
}

// 定义结构体
type Base struct {
	// 字段
	name string
	age  int
}

// 定义结构体 Base 的方法，同时也 隐式 实现了 BaseInterface 接口
func (b *Base) Show() {
	fmt.Printf("Show name=%v, age=%v\n", b.name, b.age)
}

// 组合(继承) Base
type Derived struct {
	Base // 直接嵌入即可
}

// 在 golang 中没有构造函数和析构函数，只能自己把握
func NewDerived(name string, age int) *Derived {
	// 实例化对象
	return &Derived{
		Base{
			name: name,
			age:  age,
		},
	}
}

type TestBase struct {
}

func (t *TestBase) Show() {
	fmt.Println("TestBase Show")
}

// 利用接口实现多态
func Show(b BaseInterface) {
	b.Show()
}

func main() {
	derived := NewDerived("laixhe", 18)
	derived.Show() // 结果： Show name=laixhe, age=18

	// 实例化对象
	testBase := &TestBase{}
	testBase.Show() // 结果： TestBase Show

	Show(derived)  // 结果： Show name=laixhe, age=18
	Show(testBase) // 结果： TestBase Show
}
```

##### 2. TypeScript
```
// 定义接口
interface BaseInterface {
    id: number;
    name: string;
    show(): void;
}

// 定义类并实现了 BaseInterface 接口
class Base implements BaseInterface{
    id:   number = 0; // 字段最好给于初始默认值否则为 undefined
    name: string = '';
    // 构造函数
    constructor(id: number, name: string){
        this.id = id;
        this.name = name;
    }
    // 成员方法并实现 BaseInterface 接口的方法
    show(): void {
        console.log(`base show id=${this.id}, name=${this.name}`);
    }
}

// 继承 Base
class TestBase extends Base {
    // 静态属性
    static age: number = 18;
    // 静态方法
    static Test(){
        console.log(this.age);
        this.age++;
    }
}

// 利用接口实现多态
function Show(b: BaseInterface): void {
    b.show();
}

// 实例化对象
let base = new Base(18, 'laixhe');
base.show();               // 结果： base show id=18, name=laixhe

// 直接调用 静态
console.log(TestBase.age); // 结果： 18
TestBase.Test();           // 结果： 18
let testBase = new TestBase(16, 'lai');
testBase.show();           // 结果： base show id=16, name=lai
TestBase.Test();           // 结果： 19

Show(base);     // 结果： base show id=18, name=laixhe
Show(testBase); // 结果： base show id=16, name=lai
```

##### 3. Dart
```
// 定义抽象类
abstract class BaseInterface {
  void Show();
}

// 定义类并实现了 BaseInterface 抽象类
class Base extends BaseInterface{
  int id = 0; // 最好给于默认值否则为 null
  String name = '';

  // 构造函数
  Base(this.id, this.name);

  @override
  void Show() {
    print('base show id=$id, name=$name');
  }
}

// 继承 Base
class TestBase extends Base {
  // 静态属性
  static int age = 0;

  TestBase(int id, String name) : super(id, name);

  @override
  void Show() {
    print('base show id=$id, name=$name');
  }

  // 静态方法
  static void Test(){
    print(age);
    age++;
  }
}

// 利用接口实现多态
void Show(BaseInterface b) {
  b.Show();
}

void main() {
  var base = Base(18, 'laixhe');
  base.Show(); // 结果：base show id=18, name=laixhe
  var testBase = TestBase(19, 'lai');
  base.Show(); // 结果：base show id=18, name=laixhe

  Show(base);     // 结果：base show id=18, name=laixhe
  Show(testBase); // 结果：base show id=19, name=lai
  
  print(TestBase.age); // 结果： 0
  TestBase.Test();     // 结果： 0
  print(TestBase.age); // 结果： 1
}
```

##### 4. Python
```
# 定义类， 用于继承
class BaseInterface:
    def Show(self):
        pass

# 定义类，并继承
class Base(BaseInterface):
    
    age: int = 0  # 类属性

    # 构造方法
    def __init__(self, _uid: int, _name: str):
        self.uid: int = _uid      # 对象实例属性
        self.name: str = _name
        self.__like: str = '爱好'  # 加两个下划线 将此属性私有化

    def Show(self):
        print("base show uid=%d, name=%s" % (self.uid, self.name))
    
    # 类方法(静态方法)
    @classmethod
    def get_age(cls) -> int:
        return cls.age
    
    # 加两个下划线 将此方法私有化
    def __get_name(self) -> str:
        return self.name
    
    # 析构方法
    def __del__(self):
        pass

# 定义类，并继承
class TestBase(BaseInterface):
    def Show(self):
        print('test base show')

# 利用类实现多态
def Show(b: BaseInterface):
    b.Show()

if __name__ == '__main__':
    base = Base(18, 'laixhe')
    base.Show()      # 结果： base show uid=18, name=laixhe
    testBase = TestBase()
    testBase.Show()  # 结果： test base show

    Show(base)      # 结果： base show uid=18, name=laixhe
    Show(testBase)  # 结果： test base show
    
    # 类属性、方法(静态)
    print(Base.age)  # 结果：0
    Base.age += 1
    Base.age += 1
    age: int = Base.get_age()
    print(age)  # 结果：2
```

##### 5. PHP
```
<?php
// 定义接口
interface BaseInterface{
    public function Show():void;
}

// 定义类并实现了 BaseInterface 接口
class Base implements BaseInterface {
    public int $id = 0;
    public string $name = '';

    // 构造函数
    public function __construct(int $id, string $name){
        $this->id   = $id;
        $this->name = $name;
    }

    // 析构函数
    //public function __destruct(){}

    // 成员方法并实现 BaseInterface 接口的方法
    public function Show(): void {
        echo 'base show id=', $this->id, 'name=', $this->name;
    }
}

// 利用接口实现多态
function Show(BaseInterface $b): void {
    $b->Show();
}

// 定义类并继承 Base
class TestBase extends Base {
    // 静态属性
    public static int $age = 18;
    // 静态方法
    public static function Test(){
        echo self::$age;
        self::$age++;
    }

    public function Show(): void {
        echo 'test base show';
    }
}

$base = new Base(18, 'laixhe');
$base->Show();     // 结果： base show id=18name=laixhe
echo "\n";

$testBase = new TestBase(20, 'lai');
$testBase->Show(); // 结果： test base show
echo "\n";
TestBase::Test();  // 结果： 18
echo "\n";
TestBase::Test();  // 结果： 19

echo "\n";
Show($base);       // 结果： base show id=18name=laixhe
echo "\n";
Show($testBase);   // 结果： test base show
```

##### 6. Rust
```
// trait(特质) 与接口类似 (给结构体添加定义的行为)
trait BaseTrait {
    fn show(&self);
}

// 定义结构体(结构体的声明仅包含了它内部的数据结构)
// 相关方法的实现是放在额外的 impl 语句块中的
#[derive(Debug)]
struct Base {
    id: i32,
    name: String
}

// 定义属于 Base 的方法
impl Base{
    // 相当于 静态方法
    pub fn new(id: i32, name: String) -> Base {
        Base{
            id: id,
            name: name
        }
    }
    // 实例方法
    fn set_name(&mut self, name: String) {
        // 拼接字符串
        self.name = format!("set name={}", name);
    }
}

// 实现 BaseTrait (trait(与接口类似))
impl BaseTrait for Base {
    fn show(&self) {
        println!("base show id={},name={}", self.id, self.name)
    }
}

fn main() {
    let mut base = Base{id:10, name: "laixhe".to_string()};
    println!("{:?}", base); // 结果： Base { id: 10, name: "laixhe" }
    base.set_name("lai".to_string());
    println!("{:?}", base); // 结果： Base { id: 10, name: "set name=lai" }

    let base_new = Base::new(88, String::from("base new..."));
    println!("{:?}", base_new); // 结果： Base { id: 88, name: "base new..." }
    base_new.show(); // 结果： base show id=88,name=base new...
}
```

### 常量与枚举
> golang：由关键字```const```声明常量，没有枚举类型
>
> C#：由关键字```const```声明常量，由```enum```枚举类型有数字枚举
>
> typescript：由关键字```const```声明常量，由```enum```枚举类型有数字枚举、字符串枚举，可以手动指定原始值
>
> dart：由关键字```const```声明常量，由```enum```枚举类型且不能手动指定原始值
>
> python：没有常量，没有枚举但枚举模块，可通过用 class 关键字，继承 Enum 类
>
> php：由关键字```const```声明常量，没有枚举
> 
> rust：由关键字```const```声明常量，由关键字```static```声明全局变量，而枚举```enum```和传统上的枚举是不同的更像是结构体

##### Golang
```
package main
import "fmt"

// 定义常量并使用 iota 模拟枚举
const (
	read int = iota
	green
	blue
)

const uid int = 10;
// uid =1 1; // error

func main() {
	fmt.Println(blue) // 结果： 2
}
```

##### C#
```
using System;

namespace ConsoleApp {
    class Program {
        static void Main(string[] args)
        {
            var read = Color.Read;
            Console.WriteLine("read={0}", read);
            // 一开始就得赋值
            const int uid = 10;
            //uid = 11; // error
        }
    }
    // 枚举
    // 从 0 开始为元素编号
    // 可手动指定原始值
    enum Color {
        Read,
        Green,
        Blue
    }
}
```

##### TypeScript
```
// 枚举
// 默认情况下，从 0 开始为元素编号
// 可以手动指定原始值
enum Color {
    read,
    green,
    blue
}
console.log(Color.blue); // 结果： 2

// 常量
const uid: number = 10;
//uid = 11; // error
```

##### Dart
```
// 枚举
// 从 0 开始为元素编号
// 不能手动指定原始值
enum Color {
  read,
  green,
  blue
}

// const：值不变，一开始就得赋值
const int uid = 10;
// final：可以开始不赋值，只能赋一次
final String name = 'laixhe';

void main() {
  print('${Color.blue}, ${Color.blue.index}'); // 结果： Color.blue, 2
}
```

##### Python
```
from enum import Enum, unique

# 枚举
# 使用修饰器@unique，则值也唯一不可重复
@unique
class Color(int, Enum):
    read  = 0
    green = 1
    blue  = 2

if __name__ == '__main__':
    print(Color.blue, Color.blue.name, Color.blue.value)  # 结果： Color.blue blue 2

    # 在 python 中，没有一个专门的语法代表常量，程序员约定俗成用变量名全部大写代表常量
```

##### PHP
```
<?php
// 定义常量
define('UID', 10);
const NAME = 'laixhe';

echo UID,', ', NAME, "\n"; // 结果： 10, laixhe

// 在 php 中没有枚举，使用 class 配合 const 来实现
class Color{
    const read = 0;
    const green = 1;
    const blue = 2;
}
echo Color::blue; // 结果： 2
```

##### Rust

> 系统的枚举有 Result、Option

```
// 定义枚举
enum Color {
    Read,
    Green,
    Blue
}
// 定义枚举方法
impl Color {
    pub fn get(c: Color) -> u8 {
        match c {
            Color::Read => {
                1
            },
            Color::Green => {
                2
            },
            Color::Blue => {
                3
            }
        }
    }
}
// 定义枚举
// 可以给枚举的每一个成员，指定一个或多个数据类型
enum Operation {
    Jump(u32),
    Move {x: i32, y:i32},
}
impl Operation {
    pub fn get(o: Operation){
        match o {
            Operation::Jump(value) => {
                println!("Operation Jump: {}", value);
            },
            Operation::Move {x,y} => {
                println!("Operation Move, x: {}, y: {}", x, y);
            }
        }
    }
}

// 全局变量
static IP: &'static str = "127.0.0.1";
// 常量
const PORT: i32 = 5500;

fn main() {
    let color_blue = Color::Blue;
    println!("Color: {}", Color::get(color_blue));

    let opt_move = Operation::Move { x: 10, y: 20 };
    Operation::get(opt_move);

    println!("ip={},port={}", IP, PORT);
}
```